<!DOCTYPE html>
<html>
<head>
 <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" type="image/png" href="fcn.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">

  <title>Zettapapers</title>
</head>
<body>

  
  
  <!-- Mobile Menu Overlay -->
  <div class="menu-overlay" id="menuOverlay"></div>
  
  <div class="header">
    <a href="index.html" class="logo">
      Zettapapers
      <span class="logo-ribbon">1.0</span>
    </a>
    
    <!-- Hamburger Menu Button -->
    <button class="menu-toggle" id="menuToggle" aria-label="Toggle menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
    
    <div class="header-right" id="navMenu">
      <a class="active" href="index.html">Home</a>
<a href="infinity.html">Gallery</a>
      <a href="Category.html">Category</a>
      
      <a href="about.html">About</a>
    </div>
  </div>
  <div class="scroller-stack" style="position: relative;">
    <!-- 🔥 Infinite Image Scroller -->
  <div class="scroller">
    <div class="scroller-track left">
      <img src="nsi/IMG_20241221_074043.webp" alt="error">
      <img src="nsi/IMG_20250517_121123.jpg" alt="error">
      <img src="nsi/IMG_20250517_121655.jpg" alt="error">
      <img src="nsi/IMG_20250517_122424.jpg" alt="error">
      <img src="nsi/IMG_20250517_122745.jpg" alt="error">
      <img src="nsi/IMG_20250517_123953.jpg" alt="error">
      <img src="nsi/IMG_20250517_125241.jpg" alt="error">
      <img src="nsi/IMG_20250517_125532.jpg" alt="error">
      <img src="nsi/IMG_20250517_133701.jpg" alt="error">
      <img src="nsi/IMG_20250517_134041.jpg" alt="error">
      
      <!-- duplicate for infinite loop -->
      <img src="nsi/IMG_20241221_074043.webp" alt="error">
      <img src="nsi/IMG_20250517_121123.jpg" alt="error">
      <img src="nsi/IMG_20250517_121655.jpg" alt="error">
      <img src="nsi/IMG_20250517_122424.jpg" alt="error">
      <img src="nsi/IMG_20250517_122745.jpg" alt="error">
      <img src="nsi/IMG_20250517_123953.jpg" alt="error">
      <img src="nsi/IMG_20250517_125241.jpg" alt="error">
      <img src="nsi/IMG_20250517_125532.jpg" alt="error">
      <img src="nsi/IMG_20250517_133701.jpg" alt="error">
      <img src="nsi/IMG_20250517_134041.jpg" alt="error">
      
    </div>
  </div>
  <!--  Infinite Image Scroller -->
  <div class="scroller">
    <div class="scroller-track right">
      <img src="nsi/IMG_20250517_133822.jpg" alt="error">
      <img src="nsi/IMG_20250517_134021.jpg" alt="error">
      <img src="nsi/IMG_20250517_134955.jpg" alt="error">
      <img src="nsi/IMG_20250517_135631.jpg" alt="error">
      <img src="nsi/IMG_20250523_143257.jpg" alt="error">
      <img src="nsi/IMG_20250524_183325.jpg" alt="error">
      <img src="nsi/IMG_20250726_160439.jpg" alt="error">
      <img src="nsi/IMG_20250726_160442.jpg" alt="error">
      <img src="nsi/IMG_20250522_194341.jpg" alt="error">
      <img src="nsi/IMG_20250523_140114.jpg" alt="error">
      
      <!-- duplicate for infinite loop -->
      <img src="nsi/IMG_20250517_133822.jpg" alt="error">
      <img src="nsi/IMG_20250517_134021.jpg" alt="error">
      <img src="nsi/IMG_20250517_134955.jpg" alt="error">
      <img src="nsi/IMG_20250517_135631.jpg" alt="error">
      <img src="nsi/IMG_20250523_143257.jpg" alt="error">
      <img src="nsi/IMG_20250524_183325.jpg" alt="error">
      <img src="nsi/IMG_20250726_160439.jpg" alt="error">
      <img src="nsi/IMG_20250726_160442.jpg" alt="error">
      <img src="nsi/IMG_20250522_194341.jpg" alt="error">
      <img src="nsi/IMG_20250523_140114.jpg" alt="error">
      
    </div>
  </div>
<!-- 🔥 Infinite Image Scroller -->
  <div class="scroller">
    <div class="scroller-track left">
      <img src="nsi/IMG_20250726_164330.jpg" alt="error">
      <img src="nsi/IMG_20250726_181107.jpg" alt="error">
      <img src="nsi/IMG_20250726_181750.jpg" alt="error">
      <img src="nsi/IMG_20250813_132005.jpg" alt="error">
      <img src="nsi/IMG_20250813_132118.jpg" alt="error">
      <img src="nsi/IMG_20250813_132313.jpg" alt="error">
      <img src="nsi/IMG_20250813_132431.jpg" alt="error">
      <img src="nsi/IMG_20250813_132547.jpg" alt="error">
      <img src="nsi/Image 2025-08-16 at 19.09.17_4fc5133e.jpg" alt="error">
      <img src="nsi/Image 2025-08-16 at 19.09.18_11f802cd.jpg" alt="error">
      
      <!-- duplicate for infinite loop -->
      <img src="nsi/IMG_20250726_164330.jpg" alt="error">
      <img src="nsi/IMG_20250726_181107.jpg" alt="error">
      <img src="nsi/IMG_20250726_181750.jpg" alt="error">
      <img src="nsi/IMG_20250813_132005.jpg" alt="error">
      <img src="nsi/IMG_20250813_132118.jpg" alt="error">
      <img src="nsi/IMG_20250813_132313.jpg" alt="error">
      <img src="nsi/IMG_20250813_132431.jpg" alt="error">
      <img src="nsi/IMG_20250813_132547.jpg" alt="error">
      <img src="nsi/Image 2025-08-16 at 19.09.17_4fc5133e.jpg" alt="error">
      <img src="nsi/Image 2025-08-16 at 19.09.18_11f802cd.jpg" alt="error">
      
    </div>
  </div>
  <!-- 🔥 Infinite Image Scroller -->
  <div class="scroller">
    <div class="scroller-track right">
      <img src="nsi/Image 2025-08-16 at 19.09.30_4b3b16ec.png" alt="error">
      <img src="nsi/IMG-20250820-WA0022.jpg" alt="IMG-20250820-WA0022.jpg" loading="lazy">
      <img src="nsi/IMG-20250820-WA0023.jpg" alt="IMG-20250820-WA0023.jpg" loading="lazy">
      <img src="nsi/IMG-20250820-WA0024.jpg" alt="IMG-20250820-WA0024.jpg" loading="lazy">
      <img src="nsi/IMG-20250820-WA0025.jpg" alt="IMG-20250820-WA0025.jpg" loading="lazy">    
      <img src="nsi/IMG-20250820-WA0018.png" alt="IMG-20250820-WA0026.jpg" loading="lazy">
<img src="nsi/IMG-20250820-WA0027.jpg" alt="IMG-20250820-WA0027.jpg" loading="lazy">
<img src="nsi/IMG-20250820-WA0028.jpg" alt="IMG-20250820-WA0028.jpg" loading="lazy">
<img src="nsi/IMG-20250820-WA0029.jpg" alt="IMG-20250820-WA0029.jpg" loading="lazy">
<img src="nsi/IMG-20250820-WA0030.jpg" alt="IMG-20250820-WA0030.jpg" loading="lazy">
      
      <!-- duplicate for infinite loop -->
       <img src="nsi/Image 2025-08-16 at 19.09.30_4b3b16ec.png" alt="error">
      <img src="nsi/IMG-20250820-WA0022.jpg" alt="IMG-20250820-WA0022.jpg" loading="lazy">
      <img src="nsi/IMG-20250820-WA0023.jpg" alt="IMG-20250820-WA0023.jpg" loading="lazy">
      <img src="nsi/IMG-20250820-WA0024.jpg" alt="IMG-20250820-WA0024.jpg" loading="lazy">
      <img src="nsi/IMG-20250820-WA0025.jpg" alt="IMG-20250820-WA0025.jpg" loading="lazy">    
      <img src="nsi/IMG-20250820-WA0018.png" alt="IMG-20250820-WA0026.jpg" loading="lazy">
<img src="nsi/IMG-20250820-WA0027.jpg" alt="IMG-20250820-WA0027.jpg" loading="lazy">
<img src="nsi/IMG-20250820-WA0028.jpg" alt="IMG-20250820-WA0028.jpg" loading="lazy">
<img src="nsi/IMG-20250820-WA0029.jpg" alt="IMG-20250820-WA0029.jpg" loading="lazy">
<img src="nsi/IMG-20250820-WA0030.jpg" alt="IMG-20250820-WA0030.jpg" loading="lazy">
      
    </div>
  </div>

  <!--  Text Overlay (centered within the 4-scroller block) -->
  <div class="text-overlay" style="--slides: 8; --slot: 5s;">
    <div class="text-slide" style="--i: 0;">Welcome to Zettapapers</div>
    <div class="text-slide" style="--i: 1;">Looking for amazing wallpapers?</div>
    <div class="text-slide" style="--i: 2;">Here's a cool collection for you</div>
    <div class="text-slide" style="--i: 3;">No Ads - Just Wallpapers</div>
    <div class="text-slide" style="--i: 4;">Explore. Download. Enjoy.</div>
    <div class="text-slide" style="--i: 5;">Your Space. Your Style.</div>
    <div class="text-slide" style="--i: 6;">Smooth, Fast & Safe Downloads</div>
    <div class="text-slide" style="--i: 7;">Created for Wallpaper Lovers</div>
  </div>
  </div>

  <main class="home-main">




<!--  Features -->
<section class="features home-section">
  <div class="feature">
    <h3>🚫 No Ads</h3>
    <p>Enjoy wallpapers without annoying ads or popups.</p>
  </div>
  <div class="feature">
    <h3>⚡ Fast Downloads</h3>
    <p>one click and your wallpaper is ready. Really!</p>
  </div>
  <div class="feature">
    <h3>🪧No sign-in</h3>
    <p>No Sign-In Needed - Download Instantly</p>
  </div>
  <div class="feature">
    <h3>🖼️ 350+ Wallpapers</h3>
    <p>huge collection of wallpapers</p>
  </div>


  
</section>

<!-- Device Preview Booth -->
<section class="device-booth home-section" id="deviceBooth">
  <h2>Compare + Live Device Preview Booth</h2>
  <p>Compare medium vs high quality, then preview the same wallpaper on Phone, Tablet, and PC.</p>

  <div class="feature feature-compare booth-compare" id="qualityCompareFeature">
    <div class="compare-topline">
      <span id="comparePairCount">Loading compare pairs...</span>
      <span id="compareFileName"></span>
    </div>

    <div class="img-comp-container" id="qualityCompareContainer">
      <div class="img-comp-img">
        <img id="compareHighImg" data-skip-preview="true" src="pcnsw/IMG_20250524_183325.jpg" alt="High quality wallpaper preview" loading="lazy">
      </div>
      <div class="img-comp-img img-comp-overlay">
        <img id="compareMedImg" data-skip-preview="true" src="pcnswmed/IMG_20250524_183325.jpg" alt="Medium quality wallpaper preview" loading="lazy">
      </div>
      <span class="compare-chip compare-chip-high">HIGH</span>
      <span class="compare-chip compare-chip-med">MED</span>
    </div>

    <div class="compare-actions">
      <button id="comparePrevBtn" class="compare-btn" type="button">Prev</button>
      <button id="compareNextBtn" class="compare-btn" type="button">Next</button>
      <button id="compareDownloadMedBtn" class="compare-btn compare-btn-med" type="button">Download MED</button>
      <button id="compareDownloadHighBtn" class="compare-btn compare-btn-high" type="button">Download HIGH</button>
    </div>
  </div>

  <div class="booth-main">
    <div class="booth-stage">
      <article class="device-card">
        <div class="device-head">
          <h3>Phone</h3>
          <span class="fit-badge" id="fitPhone">Checking...</span>
        </div>
        <div class="device-frame phone-frame">
          <img id="boothPhoneImg" src="phonensw/Image 2025-08-16 at 19.09.17_4fc5133e.jpg" alt="Phone preview" loading="lazy">
        </div>
      </article>

      <article class="device-card">
        <div class="device-head">
          <h3>Tablet</h3>
          <span class="fit-badge" id="fitTablet">Checking...</span>
        </div>
        <div class="device-frame tablet-frame">
          <img id="boothTabletImg" src="phonensw/Image 2025-08-16 at 19.09.17_4fc5133e.jpg" alt="Tablet preview" loading="lazy">
        </div>
      </article>

      <article class="device-card">
        <div class="device-head">
          <h3>PC</h3>
          <span class="fit-badge" id="fitPc">Checking...</span>
        </div>
        <div class="device-frame pc-frame">
          <img id="boothPcImg" src="phonensw/Image 2025-08-16 at 19.09.17_4fc5133e.jpg" alt="PC preview" loading="lazy">
        </div>
      </article>
    </div>

    <aside class="booth-panel">
      <p class="booth-file" id="boothFileName">Image 2025-08-16 at 19.09.17_4fc5133e.jpg</p>
      <div class="booth-filters">
        <label class="booth-filter-label" for="boothSearchInput">Search</label>
        <input class="booth-input" id="boothSearchInput" type="search" placeholder="Search by name, title, or keyword" autocomplete="off">
        <label class="booth-filter-label" for="boothCategorySelect">Category</label>
        <select class="booth-select" id="boothCategorySelect">
          <option value="all">All categories</option>
        </select>
        <p class="booth-filter-count" id="boothFilterCount"></p>
      </div>
      <div class="booth-actions">
        <button class="booth-btn" id="boothRandomBtn" type="button">Show Random</button>
      </div>
      <div class="booth-thumbs" id="boothThumbs"></div>
    </aside>
  </div>
</section>
  </main>
<!--  Trend Wallpapers -->
<section class="trending home-section">
  <h2>Top selected wallpapers</h2>
  <div class="top-selected-grid">
    <img src="phonensw/Image 2025-08-16 at 19.09.17_4fc5133e.jpg" alt="Portrait wallpaper 1" loading="lazy">
    <img src="pcnsw/IMG_20250726_160442.jpg" alt="Landscape wallpaper 1" loading="lazy">
    <img src="phonensw/IMG_20241017_175138.jpg" alt="Portrait wallpaper 2" loading="lazy">
    <img src="pcnsw/IMG_20241103_184415.jpg" alt="Landscape wallpaper 2" loading="lazy">
    <img src="phonensw/IMG_20241103_173555.jpg" alt="Portrait wallpaper 3" loading="lazy">
    <img src="pcnsw/IMG_20250524_183325.jpg" alt="Landscape wallpaper 3" loading="lazy">
    <img src="phonensw/IMG_20241104_081630.jpg" alt="Portrait wallpaper 4" loading="lazy">
    <img src="pcnsw/IMG_20251023_080606.jpg" alt="Landscape wallpaper 4" loading="lazy">
    <img src="phonensw/IMG_20250517_170715.jpg" alt="Portrait wallpaper 5" loading="lazy">
    <img src="pcnsw/IMG_20250101_163344.jpg" alt="Landscape wallpaper 5" loading="lazy">
    <img src="phonensw/IMG_20241103_122817.jpg" alt="Portrait wallpaper 6" loading="lazy">
  </div>

</section>

<!-- Footer -->
<footer>
  <p>&copy; 2025 Zettapapers Wallpapers | All Rights Reserved | Designed by Daksh Jawale & helped by Dwij Ilme </p>
</footer>

<!-- Toast / Snackbar -->
<div id="toast" class="toast"></div>

<script src="main.js" defer></script>
<script>
  (function () {
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function parseSourcesFromDataFile(content) {
      const out = [];
      const re = /<img[^>]+src="([^"]+)"/g;
      let m;
      while ((m = re.exec(content)) !== null) {
        if (m[1]) out.push(m[1]);
      }
      return [...new Set(out)];
    }

    function parseWallpaperEntriesFromDataFile(content) {
      const out = [];
      const tagRe = /<img\b[^>]*>/gi;
      let m;

      function readAttr(tag, attr) {
        const re = new RegExp(`${attr}="([^"]*)"`, "i");
        const hit = tag.match(re);
        return hit && hit[1] ? hit[1].trim() : "";
      }

      while ((m = tagRe.exec(content)) !== null) {
        const tag = m[0];
        const src = readAttr(tag, "src");
        if (!src) continue;

        out.push({
          src,
          alt: readAttr(tag, "alt"),
          category: readAttr(tag, "data-category"),
          title: readAttr(tag, "data-title"),
          desc: readAttr(tag, "data-desc"),
        });
      }

      return out;
    }

    function uniqueSourcesFromFirstHalf(track) {
      const imgs = Array.from(track.querySelectorAll("img"));
      const half = Math.floor(imgs.length / 2);
      return imgs.slice(0, half).map((img) => img.getAttribute("src")).filter(Boolean);
    }

    function pickImages(pool, count) {
      if (!pool || pool.length === 0 || count <= 0) return [];
      const bag = shuffle([...pool]);
      const out = [];
      while (out.length < count) {
        out.push(bag[out.length % bag.length]);
      }
      return out;
    }

    function initComparisons() {
      const overlays = document.getElementsByClassName("img-comp-overlay");
      for (let i = 0; i < overlays.length; i++) {
        compareImages(overlays[i]);
      }

      function compareImages(img) {
        const container = img.parentElement;
        if (!container) return;

        if (typeof container._cleanupCompare === "function") {
          container._cleanupCompare();
        }

        let clicked = 0;
        let focusY = 0;
        const w = container.offsetWidth;
        const h = container.offsetHeight;
        const baseLayerImg = container.querySelector(".img-comp-img:not(.img-comp-overlay) img");
        const overlayLayerImg = img.querySelector("img");
        const zoomFactor = 3.2;

        img.style.width = `${Math.round(w / 2)}px`;
        focusY = h / 2;

        // Keep both images at full container size so overlay is clipped, not stretched.
        [baseLayerImg, overlayLayerImg].forEach((layerImg) => {
          if (!layerImg) return;
          layerImg.style.width = `${w}px`;
          layerImg.style.height = `${h}px`;
          layerImg.style.maxWidth = "none";
        });

        const medZoom = document.createElement("div");
        medZoom.className = "img-comp-zoom img-comp-zoom-med";
        container.appendChild(medZoom);

        const highZoom = document.createElement("div");
        highZoom.className = "img-comp-zoom img-comp-zoom-high";
        container.appendChild(highZoom);

        const slider = document.createElement("div");
        slider.setAttribute("class", "img-comp-slider");
        container.insertBefore(slider, img);

        slider.style.top = `${Math.round(h / 2) - Math.round(slider.offsetHeight / 2)}px`;
        slider.style.left = `${Math.round(w / 2) - Math.round(slider.offsetWidth / 2)}px`;

        function slideReady(e) {
          e.preventDefault();
          clicked = 1;
          window.addEventListener("mousemove", slideMove);
          window.addEventListener("touchmove", slideMove, { passive: false });
        }

        function slideFinish() {
          clicked = 0;
          window.removeEventListener("mousemove", slideMove);
          window.removeEventListener("touchmove", slideMove);
        }

        function slideMove(e) {
          if (!clicked) return;
          e.preventDefault();
          const cursor = getCursorPos(e);
          let pos = cursor.x;
          if (pos < 0) pos = 0;
          if (pos > w) pos = w;
          focusY = cursor.y;
          slide(pos);
        }

        function getCursorPos(e) {
          const evt = e.changedTouches ? e.changedTouches[0] : e;
          const rect = container.getBoundingClientRect();
          const x = evt.pageX - rect.left - window.pageXOffset;
          const y = evt.pageY - rect.top - window.pageYOffset;
          return {
            x,
            y,
          };
        }

        function clamp(value, min, max) {
          return Math.min(Math.max(value, min), max);
        }

        function getContainedImageRect(imageEl) {
          if (!imageEl) {
            return { x: 0, y: 0, width: w, height: h };
          }

          const naturalW = imageEl.naturalWidth || w;
          const naturalH = imageEl.naturalHeight || h;
          const imageRatio = naturalW / naturalH;
          const frameRatio = w / h;

          if (imageRatio > frameRatio) {
            const drawW = w;
            const drawH = drawW / imageRatio;
            return { x: 0, y: (h - drawH) / 2, width: drawW, height: drawH };
          }

          const drawH = h;
          const drawW = drawH * imageRatio;
          return { x: (w - drawW) / 2, y: 0, width: drawW, height: drawH };
        }

        function paintZoom(panel, imageEl, sampleX, sampleY) {
          if (!panel || !imageEl) return;

          const src = imageEl.currentSrc || imageEl.src;
          if (!src) return;

          const naturalW = imageEl.naturalWidth || w;
          const naturalH = imageEl.naturalHeight || h;
          const drawRect = getContainedImageRect(imageEl);
          const px = clamp(sampleX, drawRect.x, drawRect.x + drawRect.width);
          const py = clamp(sampleY, drawRect.y, drawRect.y + drawRect.height);
          const nx = drawRect.width > 0 ? (px - drawRect.x) / drawRect.width : 0.5;
          const ny = drawRect.height > 0 ? (py - drawRect.y) / drawRect.height : 0.5;
          const panelW = panel.clientWidth || 100;
          const panelH = panel.clientHeight || 100;
          const zoomW = naturalW * zoomFactor;
          const zoomH = naturalH * zoomFactor;

          panel.style.backgroundImage = `url("${src}")`;
          panel.style.backgroundSize = `${zoomW}px ${zoomH}px`;
          panel.style.backgroundPosition = `${Math.round(panelW / 2 - nx * zoomW)}px ${Math.round(panelH / 2 - ny * zoomH)}px`;
        }

        function updateZooms(x) {
          const y = clamp(focusY, 0, h);
          paintZoom(medZoom, overlayLayerImg, x, y);
          paintZoom(highZoom, baseLayerImg, x, y);
        }

        function slide(x) {
          img.style.width = `${x}px`;
          slider.style.left = `${x - slider.offsetWidth / 2}px`;
          updateZooms(x);
        }

        slider.addEventListener("mousedown", slideReady);
        slider.addEventListener("touchstart", slideReady, { passive: false });
        window.addEventListener("mouseup", slideFinish);
        window.addEventListener("touchend", slideFinish);

        slide(Math.round(w / 2));

        container._cleanupCompare = () => {
          window.removeEventListener("mouseup", slideFinish);
          window.removeEventListener("touchend", slideFinish);
          window.removeEventListener("mousemove", slideMove);
          window.removeEventListener("touchmove", slideMove);
          slider.remove();
          medZoom.remove();
          highZoom.remove();
        };
      }
    }

    function initComparePreviewBooth(allEntries, allSources) {
      const section = document.getElementById("deviceBooth");
      const highImg = document.getElementById("compareHighImg");
      const medImg = document.getElementById("compareMedImg");
      const pairCount = document.getElementById("comparePairCount");
      const fileName = document.getElementById("compareFileName");
      const prevBtn = document.getElementById("comparePrevBtn");
      const nextBtn = document.getElementById("compareNextBtn");
      const downloadMedBtn = document.getElementById("compareDownloadMedBtn");
      const downloadHighBtn = document.getElementById("compareDownloadHighBtn");
      const compareContainer = document.getElementById("qualityCompareContainer");
      const phoneImg = document.getElementById("boothPhoneImg");
      const tabletImg = document.getElementById("boothTabletImg");
      const pcImg = document.getElementById("boothPcImg");
      const boothFileName = document.getElementById("boothFileName");
      const randomBtn = document.getElementById("boothRandomBtn");
      const thumbsWrap = document.getElementById("boothThumbs");
      const fitPhone = document.getElementById("fitPhone");
      const fitTablet = document.getElementById("fitTablet");
      const fitPc = document.getElementById("fitPc");
      const searchInput = document.getElementById("boothSearchInput");
      const categorySelect = document.getElementById("boothCategorySelect");
      const filterCount = document.getElementById("boothFilterCount");

      if (
        !section ||
        !highImg ||
        !medImg ||
        !pairCount ||
        !fileName ||
        !prevBtn ||
        !nextBtn ||
        !downloadMedBtn ||
        !downloadHighBtn ||
        !compareContainer ||
        !phoneImg ||
        !tabletImg ||
        !pcImg ||
        !boothFileName ||
        !randomBtn ||
        !thumbsWrap ||
        !fitPhone ||
        !fitTablet ||
        !fitPc ||
        !searchInput ||
        !categorySelect ||
        !filterCount
      ) {
        return;
      }

      const fallbackSources = [
        "phonensw/Image 2025-08-16 at 19.09.17_4fc5133e.jpg",
        "pcnsw/IMG_20250524_183325.jpg",
        "tabletnsw/IMG-20250820-WA0017.jpg",
        "tabletnsw/IMG_20241013_104122.jpg",
      ];

      function toMedSource(src) {
        if (src.startsWith("phonensw/")) return `phonenswmed/${src.split("/").pop()}`;
        if (src.startsWith("pcnsw/")) return `pcnswmed/${src.split("/").pop()}`;
        if (src.startsWith("tabletnsw/")) return `tabletnswmed/${src.split("/").pop()}`;
        return "";
      }

      function normalizeText(value) {
        return String(value || "").trim();
      }

      function normalizeCategory(category) {
        const cleaned = normalizeText(category)
          .replace(/[_-]+/g, " ")
          .replace(/\s+/g, " ");
        if (!cleaned) {
          return { key: "uncategorized", label: "Uncategorized" };
        }
        const label = cleaned
          .split(" ")
          .filter(Boolean)
          .map((word) => word[0].toUpperCase() + word.slice(1))
          .join(" ");
        return {
          key: cleaned.toLowerCase(),
          label,
        };
      }

      const entryBySource = new Map();
      if (Array.isArray(allEntries)) {
        allEntries.forEach((entry) => {
          if (!entry || !entry.src || entryBySource.has(entry.src)) return;
          entryBySource.set(entry.src, {
            src: entry.src,
            alt: normalizeText(entry.alt),
            title: normalizeText(entry.title),
            desc: normalizeText(entry.desc),
            category: normalizeText(entry.category),
          });
        });
      }

      const sourcePool = [
        ...(Array.isArray(allSources) ? allSources : []),
        ...Array.from(entryBySource.keys()),
        ...fallbackSources,
      ];

      const pairs = [...new Set(sourcePool)]
        .map((src) => {
          const med = toMedSource(src);
          if (!med) return null;

          const file = src.split("/").pop() || src;
          const name = file.replace(/\.[^/.]+$/, "");
          const meta = entryBySource.get(src) || {};
          const category = normalizeCategory(meta.category);

          return {
            high: src,
            med,
            name,
            title: meta.title || name,
            alt: meta.alt || "",
            desc: meta.desc || "",
            categoryKey: category.key,
            categoryLabel: category.label,
          };
        })
        .filter(Boolean);

      if (pairs.length === 0) return;

      const categoryByKey = new Map();
      pairs.forEach((pair) => {
        if (!categoryByKey.has(pair.categoryKey)) {
          categoryByKey.set(pair.categoryKey, pair.categoryLabel);
        }
      });

      categorySelect.innerHTML = "";
      const allOption = document.createElement("option");
      allOption.value = "all";
      allOption.textContent = "All categories";
      categorySelect.appendChild(allOption);

      [...categoryByKey.entries()]
        .sort((a, b) => a[1].localeCompare(b[1]))
        .forEach(([key, label]) => {
          const option = document.createElement("option");
          option.value = key;
          option.textContent = label;
          categorySelect.appendChild(option);
        });

      let currentIndex = -1;
      let filteredIndexes = [];
      let activeThumb = null;
      let fitProbeNonce = 0;
      const thumbByIndex = new Map();

      function setBadge(el, label, type) {
        el.textContent = label;
        el.classList.remove("good", "ok");
        el.classList.add(type);
      }

      function calcFit(imageRatio, targetRatio) {
        const PERFECT_THRESHOLD = 0.1;
        const drift = Math.abs(imageRatio - targetRatio) / targetRatio;
        if (drift <= PERFECT_THRESHOLD) return { label: "Perfect", type: "good" };
        return { label: "Crop", type: "ok" };
      }

      function updateFitBadges(imgRatio) {
        const phone = calcFit(imgRatio, 9 / 19.5);
        const tablet = calcFit(imgRatio, 4 / 3);
        const pc = calcFit(imgRatio, 16 / 9);

        setBadge(fitPhone, phone.label, phone.type);
        setBadge(fitTablet, tablet.label, tablet.type);
        setBadge(fitPc, pc.label, pc.type);
      }

      function updateFitBadgesForSource(src) {
        const probeNonce = ++fitProbeNonce;
        const probe = new Image();
        let done = false;

        function fallbackRatioFromSource(path) {
          const value = String(path || "");
          if (value.startsWith("phonensw/")) return 9 / 19.5;
          if (value.startsWith("pcnsw/")) return 20 / 9;
          if (value.startsWith("tabletnsw/")) return 4 / 3;
          return 16 / 9;
        }

        function finish(ratio) {
          if (done) return;
          done = true;
          if (probeNonce !== fitProbeNonce) return;
          const safeRatio = Number.isFinite(ratio) && ratio > 0 ? ratio : fallbackRatioFromSource(src);
          updateFitBadges(safeRatio);
        }

        probe.onload = () => {
          const ratio = (probe.naturalWidth > 0 && probe.naturalHeight > 0)
            ? probe.naturalWidth / probe.naturalHeight
            : 16 / 9;
          finish(ratio);
        };

        probe.onerror = () => finish(fallbackRatioFromSource(src));
        probe.src = src;

        if (probe.complete) {
          const ratio = (probe.naturalWidth > 0 && probe.naturalHeight > 0)
            ? probe.naturalWidth / probe.naturalHeight
            : fallbackRatioFromSource(src);
          finish(ratio);
        }
      }

      function updateCompare(pair) {
        highImg.src = pair.high;
        medImg.src = pair.med;
        highImg.alt = `High quality ${pair.title}`;
        medImg.alt = `Medium quality ${pair.title}`;

        let loaded = 0;
        const ready = () => {
          loaded += 1;
          if (loaded >= 2) initComparisons();
        };

        if (highImg.complete) ready();
        else {
          highImg.onload = ready;
          highImg.onerror = ready;
        }

        if (medImg.complete) ready();
        else {
          medImg.onload = ready;
          medImg.onerror = ready;
        }
      }

      function updatePreview(previewSrc) {
        phoneImg.src = previewSrc;
        tabletImg.src = previewSrc;
        pcImg.src = previewSrc;

        const file = previewSrc.split("/").pop() || previewSrc;
        boothFileName.textContent = `${file} (${filteredIndexes.length}/${pairs.length} shown)`;
        updateFitBadgesForSource(previewSrc);
      }

      function syncActiveThumb(index) {
        const nextActive = thumbByIndex.get(index) || null;
        if (activeThumb && activeThumb !== nextActive) {
          activeThumb.classList.remove("active");
        }
        if (nextActive) {
          nextActive.classList.add("active");
          activeThumb = nextActive;
        }
      }

      function currentFilteredPosition() {
        return filteredIndexes.indexOf(currentIndex);
      }

      function updateCounts() {
        pairCount.textContent = `${filteredIndexes.length} of ${pairs.length} compare + preview images`;
        filterCount.textContent = `${filteredIndexes.length} shown`;
      }

      function renderByIndex(index) {
        if (index < 0 || index >= pairs.length) return;
        currentIndex = index;
        const pair = pairs[index];
        const pos = currentFilteredPosition();

        fileName.textContent = `${pos + 1}/${filteredIndexes.length} - ${pair.title} (${pair.categoryLabel})`;
        updateCompare(pair);
        updatePreview(pair.high);
        syncActiveThumb(currentIndex);

        const disableCycle = filteredIndexes.length <= 1;
        prevBtn.disabled = disableCycle;
        nextBtn.disabled = disableCycle;
        randomBtn.disabled = filteredIndexes.length === 0;
        downloadMedBtn.disabled = false;
        downloadHighBtn.disabled = false;
      }

      function buildThumbs() {
        thumbsWrap.innerHTML = "";
        thumbByIndex.clear();

        if (filteredIndexes.length === 0) {
          const empty = document.createElement("p");
          empty.className = "booth-empty";
          empty.textContent = "No wallpapers match your search.";
          thumbsWrap.appendChild(empty);
          return;
        }

        const frag = document.createDocumentFragment();
        filteredIndexes.forEach((pairIndex) => {
          const pair = pairs[pairIndex];
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "booth-thumb";
          btn.dataset.index = String(pairIndex);
          btn.title = pair.title;
          btn.setAttribute("aria-label", `Preview ${pair.title}`);

          const img = document.createElement("img");
          img.src = pair.high;
          img.alt = pair.title;
          img.loading = "lazy";
          img.decoding = "async";
          img.fetchPriority = "low";
          btn.appendChild(img);

          btn.addEventListener("click", () => renderByIndex(pairIndex));
          thumbByIndex.set(pairIndex, btn);
          frag.appendChild(btn);
        });

        if (typeof window.applyWebpPreviews === "function") {
          window.applyWebpPreviews(frag);
        }

        thumbsWrap.appendChild(frag);
      }

      function applyFilters(preferredIndex) {
        const query = normalizeText(searchInput.value).toLowerCase();
        const category = normalizeText(categorySelect.value) || "all";

        filteredIndexes = pairs
          .map((pair, idx) => ({ pair, idx }))
          .filter(({ pair }) => {
            if (category !== "all" && pair.categoryKey !== category) return false;
            if (!query) return true;

            const haystack = [
              pair.name,
              pair.title,
              pair.alt,
              pair.desc,
              pair.categoryLabel,
            ].join(" ").toLowerCase();
            return haystack.includes(query);
          })
          .map(({ idx }) => idx);

        updateCounts();
        buildThumbs();

        if (filteredIndexes.length === 0) {
          currentIndex = -1;
          fileName.textContent = "No matching wallpapers";
          boothFileName.textContent = "No matching wallpapers";
          prevBtn.disabled = true;
          nextBtn.disabled = true;
          randomBtn.disabled = true;
          downloadMedBtn.disabled = true;
          downloadHighBtn.disabled = true;
          return;
        }

        const nextIndex = (typeof preferredIndex === "number" && filteredIndexes.includes(preferredIndex))
          ? preferredIndex
          : filteredIndexes[0];
        renderByIndex(nextIndex);
      }

      prevBtn.addEventListener("click", () => {
        if (filteredIndexes.length === 0) return;
        const pos = currentFilteredPosition();
        const prevPos = (pos - 1 + filteredIndexes.length) % filteredIndexes.length;
        renderByIndex(filteredIndexes[prevPos]);
      });

      nextBtn.addEventListener("click", () => {
        if (filteredIndexes.length === 0) return;
        const pos = currentFilteredPosition();
        const nextPos = (pos + 1) % filteredIndexes.length;
        renderByIndex(filteredIndexes[nextPos]);
      });

      randomBtn.addEventListener("click", () => {
        if (filteredIndexes.length === 0) return;
        if (filteredIndexes.length === 1) {
          renderByIndex(filteredIndexes[0]);
          return;
        }

        let randomPos = Math.floor(Math.random() * filteredIndexes.length);
        const currentPos = currentFilteredPosition();
        if (randomPos === currentPos) {
          randomPos = (randomPos + 1) % filteredIndexes.length;
        }
        renderByIndex(filteredIndexes[randomPos]);
      });

      function buildDownloadName(pair, quality, src) {
        const extMatch = (src || "").match(/\.[^.\/?#]+(?=$|[?#])/);
        const ext = extMatch ? extMatch[0] : ".jpg";
        const base = (pair.title || pair.name || "wallpaper")
          .replace(/[^\w.\-]+/g, "_")
          .replace(/^_+|_+$/g, "")
          .slice(0, 80) || "wallpaper";
        return `${base}_${quality}${ext}`;
      }

      async function downloadPairSource(src, fileName) {
        if (!src) return;

        if (typeof showToast === "function") {
          showToast("Downloading...");
        }

        try {
          const response = await fetch(src);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = fileName || "wallpaper.jpg";
          document.body.appendChild(a);
          a.click();
          a.remove();

          URL.revokeObjectURL(url);
          if (typeof showToast === "function") {
            showToast("Download complete!");
          }
        } catch (err) {
          console.error("Compare download failed:", err);
          if (typeof showToast === "function") {
            showToast("Download failed. Please try again.");
          }
        }
      }

      downloadMedBtn.addEventListener("click", () => {
        if (currentIndex < 0 || currentIndex >= pairs.length) return;
        const pair = pairs[currentIndex];
        downloadPairSource(pair.med, buildDownloadName(pair, "MED", pair.med));
      });

      downloadHighBtn.addEventListener("click", () => {
        if (currentIndex < 0 || currentIndex >= pairs.length) return;
        const pair = pairs[currentIndex];
        downloadPairSource(pair.high, buildDownloadName(pair, "HIGH", pair.high));
      });

      searchInput.addEventListener("input", () => applyFilters(currentIndex));
      categorySelect.addEventListener("change", () => applyFilters(currentIndex));

      window.addEventListener("resize", () => {
        clearTimeout(compareContainer._resizeTimer);
        compareContainer._resizeTimer = setTimeout(() => initComparisons(), 120);
      });

      applyFilters(0);
    }

    function applyToTrack(track, pool) {
      if (!pool || pool.length === 0) return;

      const scroller = track.closest(".scroller");
      const rowWidth = (scroller && scroller.clientWidth) || window.innerWidth || 1200;

      // Use conservative (smaller) tile estimates so rows always overfill wide screens.
      const isMobile = window.innerWidth <= 600;
      const estimatedTileWidth = isMobile ? 88 : 100;
      const estimatedGap = isMobile ? 8 : 10;
      const minHalf = Math.ceil((rowWidth + 320) / (estimatedTileWidth + estimatedGap)) + 8;
      const half = Math.max(minHalf, 26);
      const poolKey = `${pool.length}:${pool[0] || ""}:${pool[pool.length - 1] || ""}`;
      const renderKey = `${Math.round(rowWidth)}|${half}|${poolKey}`;

      if (track.dataset.renderKey === renderKey) return;
      track.dataset.renderKey = renderKey;

      const picks = pickImages(pool, half);
      const finalSet = picks.concat(picks); // duplicated halves for seamless loop

      const frag = document.createDocumentFragment();
      finalSet.forEach((src) => {
        const img = document.createElement("img");
        img.src = src;
        img.alt = src.split("/").pop() || "wallpaper";
        img.loading = "lazy";
        img.decoding = "async";
        frag.appendChild(img);
      });

      track.innerHTML = "";
      track.appendChild(frag);

      if (typeof window.applyWebpPreviews === "function") {
        window.applyWebpPreviews(track);
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      const tracks = Array.from(document.querySelectorAll(".scroller-track"));
      const fallbackPool = tracks.length > 0
        ? [...new Set(tracks.flatMap(uniqueSourcesFromFirstHalf))]
        : [];
      const dataFiles = ["ndata/data.txt", "ndata/data2.txt", "ndata/data3.txt"];

      Promise.all(
        dataFiles.map((file) =>
          fetch(file, { cache: "force-cache" })
            .then((res) => (res.ok ? res.text() : ""))
            .catch(() => "")
        )
      ).then((texts) => {
        const datasets = texts.map((text) => parseSourcesFromDataFile(text));
        const entrySets = texts.map((text) => parseWallpaperEntriesFromDataFile(text));
        const allEntries = [...new Map(entrySets.flat().map((entry) => [entry.src, entry])).values()];
        const allSources = [...new Set(datasets.flat())];
        initComparePreviewBooth(allEntries, allSources);

        if (tracks.length === 0) return;

        const usableSets = datasets.filter((set) => set.length > 0);
        const activeSets = usableSets.length > 0 ? usableSets : [fallbackPool];

        const renderTracks = () => {
          // Track 1 -> data1, Track 2 -> data2, Track 3 -> data3, then repeat.
          tracks.forEach((track, idx) => {
            const set = activeSets[idx % activeSets.length];
            applyToTrack(track, set);
          });
        };

        renderTracks();

        // Rebuild after resize so wide screens never show animation gaps.
        let resizeTimer;
        let lastViewportWidth = window.innerWidth;
        window.addEventListener("resize", () => {
          const nextViewportWidth = window.innerWidth;
          if (Math.abs(nextViewportWidth - lastViewportWidth) < 24) return;
          lastViewportWidth = nextViewportWidth;

          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(() => requestAnimationFrame(renderTracks), 160);
        });
      });
    });
  })();
</script>
</body>
</html>
